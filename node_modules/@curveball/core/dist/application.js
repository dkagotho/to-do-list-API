"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.invokeMiddlewares = exports.middlewareCall = void 0;
const http_errors_1 = require("@curveball/http-errors");
const events_1 = require("events");
const http = require("http");
const base_context_1 = require("./base-context");
const memory_request_1 = require("./memory-request");
const memory_response_1 = require("./memory-response");
const not_found_1 = require("./middleware/not-found");
const http_utils_1 = require("./node/http-utils");
const request_1 = require("./node/request");
const response_1 = require("./node/response");
const WebSocket = require("ws");
// eslint-disable-next-line @typescript-eslint/no-var-requires
const pkg = require('../package.json');
/**
 * The middleware-call Symbol is a special symbol that might exist as a
 * property on an object.
 *
 * If it exists, the object can be used as a middleware.
 */
const middlewareCall = Symbol('middleware-call');
exports.middlewareCall = middlewareCall;
// Calls a series of middlewares, in order.
async function invokeMiddlewares(ctx, fns) {
    if (fns.length === 0) {
        return;
    }
    const mw = fns[0];
    let mwFunc;
    if (isMiddlewareObject(mw)) {
        mwFunc = mw[middlewareCall].bind(fns[0]);
    }
    else {
        mwFunc = mw;
    }
    return mwFunc(ctx, async () => {
        await invokeMiddlewares(ctx, fns.slice(1));
    });
}
exports.invokeMiddlewares = invokeMiddlewares;
function isMiddlewareObject(input) {
    return (input[middlewareCall] !== undefined);
}
class Application extends events_1.EventEmitter {
    constructor() {
        super(...arguments);
        this.middlewares = [];
    }
    /**
     * Add a middleware to the application.
     *
     * Middlewares are called in the order they are added.
     */
    use(...middleware) {
        this.middlewares.push(...middleware);
    }
    /**
     * Handles a single request and calls all middleware.
     */
    async handle(ctx) {
        ctx.response.headers.set('Server', 'curveball/' + pkg.version);
        ctx.response.type = 'application/hal+json';
        await invokeMiddlewares(ctx, [...this.middlewares, not_found_1.default]);
    }
    /**
     * Starts a HTTP server on the specified port.
     */
    listen(port, host) {
        const server = http.createServer(this.callback());
        server.on('upgrade', this.upgradeCallback.bind(this));
        return server.listen(port, host);
    }
    listenWs(port, host) {
        const wss = new WebSocket.Server({
            port,
            host
        });
        wss.on('connection', async (ws, req) => {
            const request = new request_1.default(req);
            const response = new memory_response_1.default();
            const context = new base_context_1.default(request, response);
            context.webSocket = ws;
            await this.handle(context);
        });
        return wss;
    }
    /**
     * This function is a callback that can be used for Node's http.Server,
     * https.Server, or http2.Server.
     */
    callback() {
        return async (req, res) => {
            try {
                const ctx = this.buildContextFromHttp(req, res);
                await this.handle(ctx);
                http_utils_1.sendBody(res, ctx.response.body);
            }
            catch (err) {
                // eslint-disable-next-line no-console
                console.error(err);
                if (http_errors_1.isHttpError(err)) {
                    res.statusCode = err.httpStatus;
                }
                else {
                    res.statusCode = 500;
                }
                res.setHeader('Content-Type', 'text/plain');
                res.end('Uncaught exception. No middleware was defined to handle it. We got the following HTTP status: ' +
                    res.statusCode);
                if (this.listenerCount('error')) {
                    this.emit('error', err);
                }
            }
        };
    }
    /**
     * This callback can be used to tie to the Node.js Http(s/2) server 'upgrade' event'.
     *
     * It's used to facilitate incoming Websocket requests
     */
    upgradeCallback(request, socket, head) {
        if (!this.wss) {
            // We don't have an existing Websocket server. Lets make one.
            this.wss = new WebSocket.Server({ noServer: true });
        }
        this.wss.handleUpgrade(request, socket, head, (ws) => {
            this.wss.emit('connection', ws, request);
        });
    }
    async subRequest(arg1, path, headers, body = '') {
        let request;
        if (typeof arg1 === 'string') {
            request = new memory_request_1.default(arg1, path, headers, body);
        }
        else {
            request = arg1;
        }
        const context = new base_context_1.default(request, new memory_response_1.default());
        try {
            await this.handle(context);
        }
        catch (err) {
            // eslint-disable-next-line no-console
            console.error(err);
            if (this.listenerCount('error')) {
                this.emit('error', err);
            }
            if (http_errors_1.isHttpError(err)) {
                context.response.status = err.httpStatus;
            }
            else {
                context.response.status = 500;
            }
            context.response.body =
                'Uncaught exception. No middleware was defined to handle it. We got the following HTTP status: ' +
                    context.response.status;
        }
        return context.response;
    }
    /**
     * Creates a Context object based on a node.js request and response object.
     */
    buildContextFromHttp(req, res) {
        const context = new base_context_1.default(new request_1.default(req), new response_1.default(res));
        return context;
    }
}
exports.default = Application;
//# sourceMappingURL=application.js.map