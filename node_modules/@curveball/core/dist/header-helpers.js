"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.splitHeader = exports.parsePrefer = exports.is = void 0;
/**
 * This method will return true or false if a Request or Response has a
 * Content-Type header that matches the argument.
 *
 * For example, if the Content-Type header has the value: application/hal+json,
 * then the arguments will all return true:
 *
 * * application/hal+json
 * * application/json
 * * hal+json
 * * json
 * * application/*
 */
function is(message, type) {
    const messageType = message.type;
    // No Content-Type header
    if (!messageType) {
        return false;
    }
    if (type === messageType) {
        // Matches application/hal+json
        return true;
    }
    const [mainType, subType] = messageType.split('/', 2);
    if (subType === type) {
        // Matches hal+json
        return true;
    }
    if (type === mainType + '/*') {
        // matches application/*
        return true;
    }
    const subTypeParts = subType.split('+', 2);
    if (subTypeParts.length === 2) {
        if (subTypeParts[1] === type) {
            // Matches 'json'
            return true;
        }
        if (mainType + '/' + subTypeParts[1] === type) {
            // matches application/json
            return true;
        }
    }
    return false;
}
exports.is = is;
/**
 * Parses a RFC7240 Prefer header.
 *
 * It's a naive parser as it assumes a fairly simple subset of
 * Prefer.
 *
 * TODO: Make this parse every possible variation.
 */
function parsePrefer(header) {
    if (!header) {
        return {};
    }
    const result = {};
    for (const headerItem of splitHeader(header)) {
        const [keyValue] = headerItem.split(';');
        const [key, value] = keyValue.split('=');
        result[key.toLowerCase()] = value !== undefined ? value : true;
    }
    return result;
}
exports.parsePrefer = parsePrefer;
/**
 * This function takes a multi-value comma-separated header and splits it
 * into multiple headers.
 *
 * TODO: In the future this function will respect comma's appearing within
 * quotes and ignore them. It doesn't right now.
 */
function splitHeader(header) {
    return header.split(',').map(item => item.trim());
}
exports.splitHeader = splitHeader;
//# sourceMappingURL=header-helpers.js.map