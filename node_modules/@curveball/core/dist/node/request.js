"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeRequest = void 0;
const rawBody = require("raw-body");
const headers_1 = require("../headers");
const request_1 = require("../request");
class NodeRequest extends request_1.default {
    constructor(inner) {
        super(inner.method, inner.url);
        this.inner = inner;
        // @ts-expect-error ignoring that headers might be undefined
        this.headers = new headers_1.Headers(this.inner.headers);
    }
    rawBody(encoding, limit) {
        const options = {};
        if (limit) {
            options.limit = limit;
        }
        if (encoding) {
            options.encoding = encoding;
        }
        const length = this.headers.get('Content-Length');
        if (length) {
            options.length = length;
        }
        return rawBody(this.inner, options);
    }
    /**
     * getStream returns a Node.js readable stream.
     *
     * A stream can typically only be read once.
     */
    getStream() {
        return this.inner;
    }
    /**
     * Returns the IP address of the HTTP client.
     *
     * If trustProxy is set to true, it means this server is running behind a
     * proxy, and the X-Forwarded-For header should be used instead.
     */
    ip(trustProxy = false) {
        if (trustProxy) {
            const forwardedForHeader = this.headers.get('X-Forwarded-For');
            if (forwardedForHeader) {
                return forwardedForHeader.split(',')[0].trim();
            }
        }
        return this.inner.socket.remoteAddress;
    }
}
exports.NodeRequest = NodeRequest;
exports.default = NodeRequest;
//# sourceMappingURL=request.js.map