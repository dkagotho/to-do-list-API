"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isHttpError(e) {
    return Number.isInteger(e.httpStatus);
}
exports.isHttpError = isHttpError;
function isHttpProblem(e) {
    return e.title !== undefined && isHttpError(e);
}
exports.isHttpProblem = isHttpProblem;
class HttpErrorBase extends Error {
    constructor(detail = null) {
        super(detail);
        this.type = null;
        this.httpStatus = 500;
        this.title = 'Internal Server Error';
        this.detail = null;
        this.instance = null;
        this.detail = detail;
        this.message = detail;
    }
}
exports.HttpErrorBase = HttpErrorBase;
function isClientError(e) {
    return isHttpError(e) && e.httpStatus >= 400 && e.httpStatus <= 499;
}
exports.isClientError = isClientError;
function isServerError(e) {
    return isHttpError(e) && e.httpStatus >= 500 && e.httpStatus <= 599;
}
exports.isServerError = isServerError;
class BadRequest extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 400;
        this.title = 'Bad Request';
    }
}
exports.BadRequest = BadRequest;
/**
 * Emits a 401 Unauthorized.
 *
 * This response must come with a WWW-Authenticate header. This challenge can
 * optionally be provided via the constructor.
 *
 * examples:
 *    new Unauthorized('Login failed', 'Basic');
 *    new Unauthorized('Login failed', 'Basic; realm="secret area"');
 *    new Unauthorized('Login failed', ['Basic; realm="secret area', 'Bearer']);
 */
class Unauthorized extends HttpErrorBase {
    constructor(detail = null, wwwAuthenticate) {
        super(detail);
        this.httpStatus = 401;
        this.title = 'Unauthorized';
        this.wwwAuthenticate = wwwAuthenticate;
    }
}
exports.Unauthorized = Unauthorized;
/**
 * Emits 402 Payment Required
 */
class PaymentRequired extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 402;
        this.title = 'Payment Required';
    }
}
exports.PaymentRequired = PaymentRequired;
/**
 * Emits 403 Forbidden
 */
class Forbidden extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 403;
        this.title = 'Forbiddden';
    }
}
exports.Forbidden = Forbidden;
/**
 * Emits 404 Not Found
 */
class NotFound extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 404;
        this.title = 'Not Found';
    }
}
exports.NotFound = NotFound;
/**
 * Emits 405 Method Not Allowed.
 *
 * The 405 Method Not Allowed HTTP response requires an Allow header.
 * You can optionally use the second argument to provide this.
 *
 * Example:
 *   new MethodNotAllowed('This resource is read-only', ['GET', 'HEAD', 'OPTIONS']);
 */
class MethodNotAllowed extends HttpErrorBase {
    constructor(detail = null, allow) {
        super(detail);
        this.httpStatus = 405;
        this.title = 'Method Not Allowed';
        this.allow = allow;
    }
}
exports.MethodNotAllowed = MethodNotAllowed;
/**
 * Emits 406 Not Acceptable
 */
class NotAcceptable extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 406;
        this.title = 'Not Acceptable';
    }
}
exports.NotAcceptable = NotAcceptable;
/**
 * Emits a 407 Proxy Autentication Required
 *
 * This response must come with a Proxy-Authenticate header. This challenge can
 * optionally be provided via the constructor.
 *
 * examples:
 *    new ProxyAuthenticationRequired('Login failed', 'Basic');
 *    new ProxyAuthenticationRequired('Login failed', 'Basic; realm="secret area"');
 *    new ProxyAuthenticationRequired('Login failed', ['Basic; realm="secret area', 'Bearer']);
 */
class ProxyAuthenticationRequired extends HttpErrorBase {
    constructor(detail = null, proxyAuthenticate) {
        super(detail);
        this.httpStatus = 407;
        this.title = 'Proxy Authentication Required';
        this.proxyAuthenticate = proxyAuthenticate;
    }
}
exports.ProxyAuthenticationRequired = ProxyAuthenticationRequired;
/**
 * Emits 408 Request Timeout
 */
class RequestTimeout extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 408;
        this.title = 'Request Timeout';
    }
}
exports.RequestTimeout = RequestTimeout;
/**
 * Emits 409 Conflict
 */
class Conflict extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 409;
        this.title = 'Conflict';
    }
}
exports.Conflict = Conflict;
/**
 * Emits 410 Gone
 */
class Gone extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 410;
        this.title = 'Gone';
    }
}
exports.Gone = Gone;
/**
 * Emits 411 Length Required
 */
class LengthRequired extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 411;
        this.title = 'LengthRequired';
    }
}
exports.LengthRequired = LengthRequired;
/**
 * Emits 412 Precondition Failed
 */
class PreconditionFailed extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 412;
        this.title = 'PreconditionFailed';
    }
}
exports.PreconditionFailed = PreconditionFailed;
/**
 * Emits 413 Payload Too Large.
 *
 * If the status is temporary, it's possible for a server to send a
 * Retry-After header to try again. This value may be embeded in this
 * exception.
 *
 * Example:
 *
 * throw new PayloadTooLarge('Send the large file again in 10 minutes', 600);
 */
class PayloadTooLarge extends HttpErrorBase {
    constructor(detail = null, retryAfter = null) {
        super(detail);
        this.httpStatus = 413;
        this.title = 'Payload Too Large';
        this.retryAfter = retryAfter;
    }
}
exports.PayloadTooLarge = PayloadTooLarge;
/**
 * Emits 414 URI Too Long
 */
class UriTooLong extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 414;
        this.title = 'URI Too Long';
    }
}
exports.UriTooLong = UriTooLong;
/**
 * Emits 415 Unsupported Media Type
 */
class UnsupportedMediaType extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 415;
        this.title = 'Unsupported Media Type';
    }
}
exports.UnsupportedMediaType = UnsupportedMediaType;
/**
 * Emits 416 Range Not Satisfiable
 */
class RangeNotSatisfiable extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 416;
        this.title = 'Range Not Satisfiable';
    }
}
exports.RangeNotSatisfiable = RangeNotSatisfiable;
/**
 * Emits 417 Expectation Failed
 */
class ExpectationFailed extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 417;
        this.title = 'Expectation Failed';
    }
}
exports.ExpectationFailed = ExpectationFailed;
/**
 * Emits 421 Misdirected Request
 */
class MisdirectedRequest extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 421;
        this.title = 'Misdirected Request';
    }
}
exports.MisdirectedRequest = MisdirectedRequest;
/**
 * Emits 422 Unprocessable Entity
 */
class UnprocessableEntity extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 422;
        this.title = 'Unprocessable Entity';
    }
}
exports.UnprocessableEntity = UnprocessableEntity;
/**
 * Emits 423 Locked
 */
class Locked extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 423;
        this.title = 'Locked';
    }
}
exports.Locked = Locked;
/**
 * Emits 424 FailedDependency
 */
class FailedDependency extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 424;
        this.title = 'Failed Dependency';
    }
}
exports.FailedDependency = FailedDependency;
/**
 * Emits 425 Too Early
 */
class TooEarly extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 425;
        this.title = 'Too Early';
    }
}
exports.TooEarly = TooEarly;
/**
 * Emits 426 Upgrade Required
 */
class UpgradeRequired extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 426;
        this.title = 'Upgrade Required';
    }
}
exports.UpgradeRequired = UpgradeRequired;
/**
 * Emits 428 Precondition Required
 */
class PreconditionRequired extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 428;
        this.title = 'Precondition Required';
    }
}
exports.PreconditionRequired = PreconditionRequired;
/**
 * Emits 429 Too Many Requests
 *
 * When sending this status the server may also send a Retry-After header
 * indicating when it's safe try again.
 *
 * It's possible to supply this information via the second argument.
 *
 * Example:
 *   throw new ServiceUnavailable('We\'re down temporarily', 600)
 *
 */
class TooManyRequests extends HttpErrorBase {
    constructor(detail = null, retryAfter = null) {
        super(detail);
        this.httpStatus = 429;
        this.title = 'Too Many Requests';
        this.retryAfter = retryAfter;
    }
}
exports.TooManyRequests = TooManyRequests;
/**
 * Emits 431 Request Header Fields Too Large
 */
class RequestHeaderFieldsTooLarge extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 431;
        this.title = 'Request Header Fields Too Large';
    }
}
exports.RequestHeaderFieldsTooLarge = RequestHeaderFieldsTooLarge;
/**
 * Emits 451 Unavailable For Legal Reasons
 */
class UnavailableForLegalReasons extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 451;
        this.title = 'Unavailable For Legal Reasons';
    }
}
exports.UnavailableForLegalReasons = UnavailableForLegalReasons;
/**
 * Emits 500 Internal Server Error
 */
class InternalServerError extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 500;
        this.title = 'Internal Server Error';
    }
}
exports.InternalServerError = InternalServerError;
/**
 * Emits 501 Not Implemented
 */
class NotImplemented extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 501;
        this.title = 'Not Implemented';
    }
}
exports.NotImplemented = NotImplemented;
/**
 * Emits 502 Bad Gateway
 */
class BadGateway extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 502;
        this.title = 'Bad Gateway';
    }
}
exports.BadGateway = BadGateway;
/**
 * Emits 503 Service Unavailable.
 *
 * When sending this status the server may also send a Retry-After header
 * indicating when it's safe try again.
 *
 * It's possible to supply this information via the second argument.
 *
 * Example:
 *   throw new ServiceUnavailable('We\'re down temporarily', 600)
 *
 */
class ServiceUnavailable extends HttpErrorBase {
    constructor(detail = null, retryAfter = null) {
        super(detail);
        this.httpStatus = 503;
        this.title = 'Service Unavailable';
        this.retryAfter = retryAfter;
    }
}
exports.ServiceUnavailable = ServiceUnavailable;
/**
 * Emits 504 Gateway Timeout
 */
class GatewayTimeout extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 504;
        this.title = 'Gateway Timeout';
    }
}
exports.GatewayTimeout = GatewayTimeout;
/**
 * Emits 505 HTTP Version Not Supported
 */
class HttpVersionNotSupported extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 505;
        this.title = 'HTTP Version Not Supported';
    }
}
exports.HttpVersionNotSupported = HttpVersionNotSupported;
/**
 * Emits 506 Variant Also Negotiates
 */
class VariantAlsoNegotiates extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 506;
        this.title = 'Variant Also Negotiates';
    }
}
exports.VariantAlsoNegotiates = VariantAlsoNegotiates;
/**
 * Emits 507 Insufficient Storage
 */
class UnsufficientStorage extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 507;
        this.title = 'Unsufficient Storage';
    }
}
exports.UnsufficientStorage = UnsufficientStorage;
/**
 * Emits 508 Loop Detected
 */
class LoopDetected extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 508;
        this.title = 'Loop Detected';
    }
}
exports.LoopDetected = LoopDetected;
/**
 * Emits 510 Not Extended
 */
class NotExtended extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 510;
        this.title = 'Not Extended';
    }
}
exports.NotExtended = NotExtended;
/**
 * Emits 511 Network Authentication Required
 */
class NetworkAuthenticationRequired extends HttpErrorBase {
    constructor() {
        super(...arguments);
        this.httpStatus = 511;
        this.title = 'Network Authentication Required';
    }
}
exports.NetworkAuthenticationRequired = NetworkAuthenticationRequired;
//# sourceMappingURL=index.js.map