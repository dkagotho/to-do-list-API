"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@curveball/core");
const http_errors_1 = require("@curveball/http-errors");
const http = require("http");
const path_to_regexp_1 = require("path-to-regexp");
function route(path, middleware) {
    if (typeof middleware === 'undefined') {
        return methodRoute(path);
    }
    else {
        return anyMethodRoute(path, middleware);
    }
}
exports.default = route;
function anyMethodRoute(path, middleware) {
    const m = path_to_regexp_1.match(path);
    return (ctx, next) => {
        const result = m(ctx.path);
        if (result === false) {
            return next();
        }
        ctx.params = result.params;
        // This is deprecated
        ctx.state.params = result.params;
        return core_1.invokeMiddlewares(ctx, [
            middleware,
            () => next()
        ]);
    };
}
function methodRoute(path) {
    const m = path_to_regexp_1.match(path);
    const perMethodMw = {};
    const dispatcher = (ctx, next) => {
        const result = m(ctx.path);
        if (result === false) {
            // Path did not match
            return next();
        }
        ctx.params = result.params;
        // This is deprecated
        ctx.state.params = result.params;
        if (perMethodMw[ctx.method] === undefined) {
            throw new http_errors_1.MethodNotAllowed();
        }
        return core_1.invokeMiddlewares(ctx, [
            perMethodMw[ctx.method],
            () => next()
        ]);
    };
    for (const method of http.METHODS) {
        dispatcher[method.toLowerCase()] = (methodMw) => {
            perMethodMw[method] = methodMw;
            return dispatcher;
        };
    }
    return dispatcher;
}
//# sourceMappingURL=router.js.map