"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const core_1 = require("@curveball/core");
const http_errors_1 = require("@curveball/http-errors");
const http = require("http");
const path_to_regexp_1 = require("path-to-regexp");
require("./declarations");
function route(path, ...middlewares) {
    if (middlewares.length === 0) {
        return methodRoute(path);
    }
    else {
        return anyMethodRoute(path, ...middlewares);
    }
}
exports.default = route;
function anyMethodRoute(path, ...middlewares) {
    const m = path_to_regexp_1.match(path);
    return (ctx, next) => {
        const result = m(ctx.path);
        if (result === false) {
            return next();
        }
        ctx.params = result.params;
        // This is deprecated
        ctx.state.params = result.params;
        return core_1.invokeMiddlewares(ctx, [
            ...middlewares,
            () => next()
        ]);
    };
}
function methodRoute(path) {
    const m = path_to_regexp_1.match(path);
    const perMethodMws = {};
    const dispatcherMw = (ctx, next) => {
        const result = m(ctx.path);
        if (result === false) {
            // Path did not match
            return next();
        }
        ctx.params = result.params;
        // This is deprecated
        ctx.state.params = result.params;
        if (perMethodMws[ctx.method] === undefined || perMethodMws[ctx.method].length === 0) {
            throw new http_errors_1.MethodNotAllowed();
        }
        return core_1.invokeMiddlewares(ctx, [
            ...perMethodMws[ctx.method],
            () => next()
        ]);
    };
    const dispatcher = Object.assign(dispatcherMw, {});
    for (const method of http.METHODS) {
        dispatcher[method.toLowerCase()] = (...mws) => {
            perMethodMws[method] = mws;
            return dispatcher;
        };
    }
    return dispatcher;
}
//# sourceMappingURL=index.js.map