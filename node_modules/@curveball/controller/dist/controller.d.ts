import { Context, middlewareCall, WsContext } from '@curveball/core';
import { MethodAnnotation, RouteTable } from './types';
export default class Controller {
    annotations: Map<string, MethodAnnotation[]>;
    routeTable: RouteTable;
    constructor();
    /**
     * Returns a list of allowed HTTP methods for this controller.
     */
    allowedMethods(): string[];
    /**
     * The default implementation of the HTTP OPTIONS requests automatically
     * responds with an empty body an an Allow header
     */
    options(ctx: Context): void;
    /**
     * Handle Websocket requests
     */
    webSocket(ctx: WsContext): void | Promise<void>;
    /**
     * This middlewareCall symbol is a special function that marks
     * an object as a curveball middleware.
     *
     * This function will be called by curveball when it's added to
     * the middleware stack with use().
     */
    [middlewareCall](ctx: Context): Promise<void> | void;
    /**
     * This is the main request handler.
     *
     * It takes a context and figures out which controller method
     * to call, and then calls it.
     */
    dispatch(ctx: Context): Promise<void> | void;
    /**
     * For any methods on a controller that are identical in name to a HTTP
     * method, we pretend that these methods had a `@method('FOO')` annotation.
     */
    private autoAnnotateHttpMethods;
    /**
     * This method uses the information from annotations to create
     * routes
     */
    private createRouteTable;
}
